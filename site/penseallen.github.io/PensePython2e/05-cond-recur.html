<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Capítulo 5: Condicionais e recursividade | PensePython2e</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Capítulo 5: Condicionais e recursividade" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey" />
<meta property="og:description" content="Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey" />
<link rel="canonical" href="05-cond-recur.html" />
<meta property="og:url" content="https://penseallen.github.io/PensePython2e/05-cond-recur.html" />
<meta property="og:site_name" content="PensePython2e" />
<script type="application/ld+json">
{"@type":"WebPage","headline":"Capítulo 5: Condicionais e recursividade","url":"https://penseallen.github.io/PensePython2e/05-cond-recur.html","description":"Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link rel="stylesheet" href="assets/css/style.css@v=afa460130599dbde01620e86c38923f785023956.css">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">PensePython2e</h1>
      <h2 class="project-tagline">Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey</h2>
      
        <a href="https://github.com/PenseAllen/PensePython2e" class="btn">View on GitHub</a>
      
      
    </section>

    <section class="main-content">
      <h1 id="capítulo-5-condicionais-e-recursividade">Capítulo 5: Condicionais e recursividade</h1>

<p>O tópico principal deste capítulo é a instrução if, que executa códigos diferentes dependendo do estado do programa. Mas primeiro quero apresentar dois novos operadores: divisão pelo piso e módulo.</p>

<h2 id="51---divisão-pelo-piso-e-módulo">5.1 - Divisão pelo piso e módulo</h2>

<p>O operador de divisão pelo piso, //, divide dois números e arredonda o resultado para um número inteiro para baixo. Por exemplo, suponha que o tempo de execução de um filme seja de 105 minutos. Você pode querer saber a quanto isso corresponde em horas. A divisão convencional devolve um número de ponto flutuante:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">105</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">minutes</span> <span class="o">/</span> <span class="mi">60</span>
<span class="mf">1.75</span>
</code></pre></div></div>

<p>Mas não é comum escrever horas com pontos decimais. A divisão pelo piso devolve o número inteiro de horas, ignorando a parte fracionária:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">105</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hours</span> <span class="o">=</span> <span class="n">minutes</span> <span class="o">//</span> <span class="mi">60</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hours</span>
<span class="mi">1</span>
</code></pre></div></div>

<p>Para obter o resto, você pode subtrair uma hora em minutos:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">minutes</span> <span class="o">-</span> <span class="n">hours</span> <span class="o">*</span> <span class="mi">60</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">remainder</span>
<span class="mi">45</span>
</code></pre></div></div>

<p>Uma alternativa é usar o operador módulo, %, que divide dois números e devolve o resto:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">minutes</span> <span class="o">%</span> <span class="mi">60</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">remainder</span>
<span class="mi">45</span>
</code></pre></div></div>

<p>O operador módulo é mais útil do que parece. Por exemplo, é possível verificar se um número é divisível por outro – se x % y for zero, então x é divisível por y.</p>

<p>Além disso, você pode extrair o dígito ou dígitos mais à direita de um número. Por exemplo, x % 10 produz o dígito mais à direita de x (na base 10). Da mesma forma x % 100 produz os dois últimos dígitos.</p>

<p>Se estiver usando o Python 2, a divisão funciona de forma diferente. O operador de divisão, /, executa a divisão pelo piso se ambos os operandos forem números inteiros e faz a divisão de ponto flutuante se pelo menos um dos operandos for do tipo float.</p>

<h2 id="52---expressões-booleanas">5.2 - Expressões booleanas</h2>

<p>Uma expressão booleana é uma expressão que pode ser verdadeira ou falsa. Os exemplos seguintes usam o operador ==, que compara dois operandos e produz True se forem iguais e False se não forem:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">6</span>
<span class="bp">False</span>
</code></pre></div></div>

<p>True e False são valores especiais que pertencem ao tipo bool; não são strings:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">bool</span><span class="s">'&gt;</span><span class="err">
</span><span class="s">&gt;&gt;&gt; type(False)</span><span class="err">
</span><span class="s">&lt;class '</span><span class="nb">bool</span><span class="s">'&gt;</span><span class="err">
</span></code></pre></div></div>

<p>O operador == é um dos operadores relacionais; os outros são:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="c"># x não é igual a y</span>
<span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c"># x é maior que y</span>
<span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c"># x é menor que y</span>
<span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="c"># x é maior ou igual a y</span>
<span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="c"># x é menor ou igual a y</span>
</code></pre></div></div>

<p>Embora essas operações provavelmente sejam familiares para você, os símbolos do Python são diferentes dos símbolos matemáticos. Um erro comum é usar apenas um sinal de igual (=) em vez de um sinal duplo (==). Lembre-se de que = é um operador de atribuição e == é um operador relacional. Não existe =&lt; ou =&gt;.</p>

<h2 id="53---operadores-lógicos">5.3 - Operadores lógicos</h2>

<p>Há três operadores lógicos: and, or e not. A semântica (significado) destes operadores é semelhante ao seu significado em inglês. Por exemplo, x&gt; 0 and x &lt;10 só é verdade se x for maior que 0 e menor que 10.</p>

<p>n%2 == 0 or n%3 == 0 é verdadeiro se uma ou as duas condição(ões) for(em) verdadeira(s), isto é, se o número for divisível por 2 ou 3.</p>

<p>Finalmente, o operador not nega uma expressão booleana, então not (x &gt; y) é verdade se x &gt; y for falso, isto é, se x for menor que ou igual a y.</p>

<p>Falando estritamente, os operandos dos operadores lógicos devem ser expressões booleanas, mas o Python não é muito estrito. Qualquer número que não seja zero é interpretado como True:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="mi">42</span> <span class="ow">and</span> <span class="bp">True</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>Esta flexibilidade tem sua utilidade, mas há algumas sutilezas relativas a ela que podem ser confusas. Assim, pode ser uma boa ideia evitá-la (a menos que saiba o que está fazendo).</p>

<h2 id="54---execução-condicional">5.4 - Execução condicional</h2>

<p>Para escrever programas úteis, quase sempre precisamos da capacidade de verificar condições e mudar o comportamento do programa de acordo com elas. Instruções condicionais nos dão esta capacidade. A forma mais simples é a instrução if:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is positive'</span><span class="p">)</span>
</code></pre></div></div>

<p>A expressão booleana depois do if é chamada de condição. Se for verdadeira, a instrução endentada é executada. Se não, nada acontece.</p>

<p>Instruções if têm a mesma estrutura que definições de função: um cabeçalho seguido de um corpo endentado. Instruções como essa são chamadas de instruções compostas.</p>

<p>Não há limite para o número de instruções que podem aparecer no corpo, mas deve haver pelo menos uma. Ocasionalmente, é útil ter um corpo sem instruções (normalmente como um espaço reservado para código que ainda não foi escrito). Neste caso, você pode usar a instrução pass, que não faz nada.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">pass</span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="c"># A FAZER: lidar com valores negativos!</span>
</code></pre></div></div>

<h2 id="55---execução-alternativa">5.5 - Execução alternativa</h2>

<p>Uma segunda forma da instrução if é a “execução alternativa”, na qual há duas possibilidades e a condição determina qual será executada. A sintaxe pode ser algo assim:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is even'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is odd'</span><span class="p">)</span>
</code></pre></div></div>

<p>Se o resto quando x for dividido por 2 for 0, então sabemos que x é par e o programa exibe uma mensagem adequada. Se a condição for falsa, o segundo conjunto de instruções é executado. Como a condição deve ser verdadeira ou falsa, exatamente uma das alternativas será executada. As alternativas são chamadas de ramos (branches), porque são ramos no fluxo da execução.</p>

<h2 id="56---condicionais-encadeadas">5.6 - Condicionais encadeadas</h2>

<p>Às vezes, há mais de duas possibilidades e precisamos de mais que dois ramos. Esta forma de expressar uma operação de computação é uma condicional encadeada:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is less than y'</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is greater than y'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x and y are equal'</span><span class="p">)</span>
</code></pre></div></div>

<p>elif é uma abreviatura de “else if”. Novamente, exatamente um ramo será executado. Não há nenhum limite para o número de instruções elif. Se houver uma cláusula else, ela deve estar no fim, mas não é preciso haver uma.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">'a'</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">draw_a</span><span class="p">()</span>
<span class="k">elif</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">'b'</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">draw_b</span><span class="p">()</span>
<span class="k">elif</span> <span class="n">choice</span> <span class="o">==</span> <span class="s">'c'</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">draw_c</span><span class="p">()</span>
</code></pre></div></div>

<p>Cada condição é verificada em ordem. Se a primeira for falsa, a próxima é verificada, e assim por diante. Se uma delas for verdadeira, o ramo correspondente é executado e a instrução é encerrada. Mesmo se mais de uma condição for verdade, só o primeiro ramo verdadeiro é executado.</p>

<h2 id="57---condicionais-aninhadas">5.7 - Condicionais aninhadas</h2>

<p>Uma condicional também pode ser aninhada dentro de outra. Poderíamos ter escrito o exemplo na seção anterior desta forma:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x and y are equal'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is less than y'</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is greater than y'</span><span class="p">)</span>
</code></pre></div></div>

<p>A condicional exterior contém dois ramos. O primeiro ramo contém uma instrução simples. O segundo ramo contém outra instrução if, que tem outros dois ramos próprios. Esses dois ramos são instruções simples, embora pudessem ser instruções condicionais também.</p>

<p>Embora a endentação das instruções evidencie a estrutura das condicionais, condicionais aninhadas são difíceis de ler rapidamente. É uma boa ideia evitá-las quando for possível.</p>

<p>Operadores lógicos muitas vezes oferecem uma forma de simplificar instruções condicionais aninhadas. Por exemplo, podemos reescrever o seguinte código usando uma única condicional:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is a positive single-digit number.'</span><span class="p">)</span>
</code></pre></div></div>

<p>A instrução print só é executada se a colocarmos depois de ambas as condicionais, então podemos obter o mesmo efeito com o operador and:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is a positive single-digit number.'</span><span class="p">)</span>
</code></pre></div></div>

<p>Para este tipo de condição, o Python oferece uma opção mais concisa:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'x is a positive single-digit number.'</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="58---recursividade">5.8 - Recursividade</h2>

<p>É legal para uma função chamar outra; também é legal para uma função chamar a si própria. Pode não ser óbvio porque isso é uma coisa boa, mas na verdade é uma das coisas mais mágicas que um programa pode fazer. Por exemplo, veja a seguinte função:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'Blastoff!'</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">countdown</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Se n for 0 ou negativo, a palavra “Blastoff!” é exibida, senão a saída é n e então a função countdown é chamada – por si mesma – passando n-1 como argumento.</p>

<p>O que acontece se chamarmos esta função assim?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p>A execução de countdown inicia com n=3 e como n é maior que 0, ela produz o valor 3 e então chama a si mesma…</p>

<p>    A execução de countdown inicia com n=2 e como n é maior que 0, ela produz o valor 2 e então chama a si mesma…</p>

<p>        A execução de countdown inicia com n=1 e como n é maior que 0, ela produz o valor 1 e então chama a si mesma…</p>

<p>            A execução de countdown inicia com n=0 e como n não é maior que 0, ela produz a palavra “Blastoff!” e então retorna.</p>

<p>        O countdown que recebeu n=1 retorna.</p>

<p>    O countdown que recebeu n=2 retorna.</p>

<p>O countdown que recebeu n=3 retorna.</p>

<p>E então você está de volta ao <code class="highlighter-rouge">__main__</code>. Então a saída completa será assim:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="n">Blastoff</span><span class="err">!</span>
</code></pre></div></div>

<p>Uma função que chama a si mesma é dita recursiva; o processo para executá-la é a recursividade.</p>

<p>Como em outro exemplo, podemos escrever uma função que exiba uma string n vezes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_n</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">print_n</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>Se <code class="highlighter-rouge">n &lt;= 0</code> a instrução <code class="highlighter-rouge">return</code> causa a saída da função. O fluxo de execução volta imediatamente a quem fez a chamada, e as linhas restantes da função não são executadas.</p>

<p>O resto da função é similar à countdown: ela mostra s e então chama a si mesma para mostrar s mais n-1 vezes. Então o número de linhas da saída é 1 + (n - 1), até chegar a n.</p>

<p>Para exemplos simples como esse, provavelmente é mais fácil usar um loop for. Mais adiante veremos exemplos que são difíceis de escrever com um loop for e fáceis de escrever com recursividade, então é bom começar cedo.</p>

<h2 id="59---diagramas-da-pilha-para-funções-recursivas">5.9 - Diagramas da pilha para funções recursivas</h2>

<p>Em “Diagrama da pilha”, na página 55, usamos um diagrama da pilha para representar o estado de um programa durante uma chamada de função. O mesmo tipo de diagrama pode ajudar a interpretar uma função recursiva.</p>

<p>Cada vez que uma função é chamada, o Python cria um frame para conter as variáveis locais e parâmetros da função. Para uma função recursiva, pode haver mais de um frame na pilha ao mesmo tempo.</p>

<p>A Figura 5.1 mostra um diagrama da pilha para <code class="highlighter-rouge">countdown</code> chamado com n = 3.</p>

<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_0501.png" alt="Figura 5.1 – Diagrama da pilha." />
<br /><em>Figura 5.1 – Diagrama da pilha.</em></p>

<p>Como de hábito, o topo da pilha é o frame de <code class="highlighter-rouge">__main__</code>. Está vazio porque não criamos nenhuma variável em <code class="highlighter-rouge">__main__</code> nem passamos argumentos a ela.</p>

<p>Os quatro frames do countdown têm valores diferentes para o parâmetro <code class="highlighter-rouge">n</code>. O fundo da pilha, onde <code class="highlighter-rouge">n = 0</code>, é chamado caso-base. Ele não faz uma chamada recursiva, então não há mais frames.</p>

<p>Como exercício, desenhe um diagrama da pilha para <code class="highlighter-rouge">print_n</code> chamado com <code class="highlighter-rouge">s = 'Hello'</code> e <code class="highlighter-rouge">n = 2</code>. Então escreva uma função chamada <code class="highlighter-rouge">do_n</code> que tome um objeto de função e um número <code class="highlighter-rouge">n</code> como argumentos e que chame a respectiva função <code class="highlighter-rouge">n</code> vezes.</p>

<h2 id="510---recursividade-infinita">5.10 - Recursividade infinita</h2>

<p>Se a recursividade nunca atingir um caso-base, continua fazendo chamadas recursivas para sempre, e o programa nunca termina. Isso é conhecido como recursividade infinita e geralmente não é uma boa ideia. Aqui está um programa mínimo com recursividade infinita:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recurse</span><span class="p">():</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">recurse</span><span class="p">()</span>
</code></pre></div></div>

<p>Na maior parte dos ambientes de programação, um programa com recursividade infinita não é realmente executado para sempre. O Python exibe uma mensagem de erro quando a profundidade máxima de recursividade é atingida:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err"> </span> <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recurse</span>
<span class="err"> </span> <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recurse</span>
<span class="err"> </span> <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recurse</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">.</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">.</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">.</span>
<span class="err"> </span> <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">recurse</span>
<span class="nb">RuntimeError</span><span class="p">:</span> <span class="n">Maximum</span> <span class="n">recursion</span> <span class="n">depth</span> <span class="n">exceeded</span>
</code></pre></div></div>

<p>Este traceback é um pouco maior que o que vimos no capítulo anterior. Quando o erro ocorre, há mil frames de recurse na pilha!</p>

<p>Se você escrever em recursividade infinita por engano, confira se a sua função tem um caso-base que não faz uma chamada recursiva. E se houver um caso-base, verifique se você vai mesmo atingi-lo.</p>

<h2 id="511---entrada-de-teclado">5.11 - Entrada de teclado</h2>

<p>Os programas que escrevemos até agora não aceitam entradas do usuário. Eles sempre fazem a mesma coisa cada vez.</p>

<p>O Python fornece uma função integrada chamada <code class="highlighter-rouge">input</code> que interrompe o programa e espera que o usuário digite algo. Quando o usuário pressionar Return ou Enter, o programa volta a ser executado e input retorna o que o usuário digitou como uma string. No Python 2, a mesma função é chamada <code class="highlighter-rouge">raw_input</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
<span class="n">What</span> <span class="n">are</span> <span class="n">you</span> <span class="n">waiting</span> <span class="k">for</span><span class="err">?</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">text</span>
<span class="n">What</span> <span class="n">are</span> <span class="n">you</span> <span class="n">waiting</span> <span class="k">for</span><span class="err">?</span>
</code></pre></div></div>

<p>Antes de receber entradas do usuário, é uma boa ideia exibir um prompt dizendo ao usuário o que ele deve digitar. input pode ter um prompt como argumento:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'What...is your name?</span><span class="se">\\</span><span class="s">n'</span><span class="p">)</span>
<span class="n">What</span><span class="o">...</span><span class="ow">is</span> <span class="n">your</span> <span class="n">name</span><span class="err">?</span>
<span class="n">Arthur</span><span class="p">,</span> <span class="n">King</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Britons</span><span class="err">!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name</span>
<span class="n">Arthur</span><span class="p">,</span> <span class="n">King</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Britons</span><span class="err">!</span>
</code></pre></div></div>

<p>A sequência <code class="highlighter-rouge">\n</code> no final do prompt representa um newline, que é um caractere especial de quebra de linha. É por isso que a entrada do usuário aparece abaixo do prompt.</p>

<p>Se esperar que o usuário digite um número inteiro, você pode tentar converter o valor de retorno para int:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">prompt</span> <span class="o">=</span> <span class="s">'What...is the airspeed velocity of an unladen swallow?</span><span class="se">\\</span><span class="s">n'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">speed</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="n">What</span><span class="o">...</span><span class="ow">is</span> <span class="n">the</span> <span class="n">airspeed</span> <span class="n">velocity</span> <span class="n">of</span> <span class="n">an</span> <span class="n">unladen</span> <span class="n">swallow</span><span class="err">?</span>
<span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
<span class="mi">42</span>
</code></pre></div></div>

<p>Mas se o usuário digitar algo além de uma série de dígitos, você recebe um erro:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">speed</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>
<span class="n">What</span><span class="o">...</span><span class="ow">is</span> <span class="n">the</span> <span class="n">airspeed</span> <span class="n">velocity</span> <span class="n">of</span> <span class="n">an</span> <span class="n">unladen</span> <span class="n">swallow</span><span class="err">?</span>
<span class="n">What</span> <span class="n">do</span> <span class="n">you</span> <span class="n">mean</span><span class="p">,</span> <span class="n">an</span> <span class="n">African</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">European</span> <span class="n">swallow</span><span class="err">?</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
<span class="nb">ValueError</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">literal</span> <span class="k">for</span> <span class="nb">int</span><span class="p">()</span> <span class="k">with</span> <span class="n">base</span> <span class="mi">10</span>
</code></pre></div></div>

<p>Veremos como tratar este tipo de erro mais adiante.</p>

<h2 id="512---depuração">5.12 - Depuração</h2>

<p>Quando um erro de sintaxe ou de tempo de execução ocorre, a mensagem de erro contém muita informação, às vezes, até demais. As partes mais úteis são normalmente:</p>

<ul>
  <li>
    <p>que tipo de erro foi;</p>
  </li>
  <li>
    <p>onde ocorreu.</p>
  </li>
</ul>

<p>Erros de sintaxe são normalmente fáceis de encontrar, mas há algumas pegadinhas. Erros de whitespace podem ser complicados porque os espaços e tabulações são invisíveis e estamos acostumados a ignorá-los.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span>
<span class="err"> </span> <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">^</span>
<span class="nb">IndentationError</span><span class="p">:</span> <span class="n">unexpected</span> <span class="n">indent</span>
</code></pre></div></div>

<p>Neste exemplo, o problema é que a segunda linha está endentada por um espaço. Mas a mensagem de erro aponta para y, o que pode ser capcioso. Em geral, mensagens de erro indicam onde o problema foi descoberto, mas o erro real pode estar em outra parte do código, às vezes, em uma linha anterior.</p>

<p>O mesmo acontece com erros em tempo de execução. Suponha que você esteja tentando calcular a proporção de sinal a ruído em decibéis. A fórmula é SNRdb = 10 log10 (Psignal/Pnoise). No Python, você poderia escrever algo assim:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>
<span class="n">signal_power</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">noise_power</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">ratio</span> <span class="o">=</span> <span class="n">signal_power</span> <span class="o">//</span> <span class="n">noise_power</span>
<span class="n">decibels</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">decibels</span><span class="p">)</span>
</code></pre></div></div>

<p>Ao executar este programa, você recebe uma exceção:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="err"> </span> <span class="n">File</span> <span class="s">"snr.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">decibels</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
<span class="nb">ValueError</span><span class="p">:</span> <span class="n">math</span> <span class="n">domain</span> <span class="n">error</span>
</code></pre></div></div>

<p>A mensagem de erro indica a linha 5, mas não há nada de errado com esta linha. Uma opção para encontrar o verdadeiro erro é exibir o valor de ratio, que acaba sendo 0. O problema está na linha 4, que usa a divisão pelo piso em vez da divisão de ponto flutuante.</p>

<p>É preciso ler as mensagens de erro com atenção, mas não assumir que tudo que dizem esteja correto.</p>

<h2 id="513---glossário">5.13 - Glossário</h2>

<dl>
<dt><a id="glos:divisão pelo piso" href="05-cond-recur.html#termo:divisão pelo piso">divisão pelo piso</a></dt>
<dd>Um operador, denotado por //, que divide dois números e arredonda o resultado para baixo (em direção ao zero), a um número inteiro.</dd>

<dt><a id="glos:operador módulo" href="05-cond-recur.html#termo:operador módulo">operador módulo</a></dt>
<dd>Um operador, denotado com um sinal de percentagem (%), que funciona com números inteiros e devolve o resto quando um número é dividido por outro.</dd>

<dt><a id="glos:expressão booleana" href="05-cond-recur.html#termo:expressão booleana">expressão booleana</a></dt>
<dd>Uma expressão cujo valor é True (verdadeiro) ou False (falso).</dd>

<dt><a id="glos:operador relacional" href="05-cond-recur.html#termo:operador relacional">operador relacional</a></dt>
<dd>Um destes operadores, que compara seus operandos: `==`, `!=`, `&gt;`, `&lt;`, `&gt;=` e `&lt;=`.</dd>

<dt><a id="glos:operador lógico" href="05-cond-recur.html#termo:operador lógico">operador lógico</a></dt>
<dd>Um destes operadores, que combina expressões booleanas: and (e), or (ou) e not (não).</dd>

<dt><a id="glos:instrução condicional" href="05-cond-recur.html#termo:instrução condicional">instrução condicional</a></dt>
<dd>Uma instrução que controla o fluxo de execução, dependendo de alguma condição.</dd>

<dt><a id="glos:condição" href="05-cond-recur.html#termo:condição">condição</a></dt>
<dd>A expressão booleana em uma instrução condicional que determina qual ramo deve ser executado.</dd>

<dt><a id="glos:instrução composta" href="05-cond-recur.html#termo:instrução composta">instrução composta</a></dt>
<dd>Uma instrução composta de um cabeçalho e um corpo. O cabeçalho termina em dois pontos (:). O corpo é endentado em relação ao cabeçalho.</dd>

<dt><a id="glos:ramo" href="05-cond-recur.html#termo:ramo">ramo</a></dt>
<dd>Uma das sequências alternativas de instruções em uma instrução condicional.</dd>

<dt><a id="glos:condicional encadeada" href="05-cond-recur.html#termo:condicional encadeada">condicional encadeada</a></dt>
<dd>Uma instrução condicional com uma série de ramos alternativos.</dd>

<dt><a id="glos:condicional aninhada" href="05-cond-recur.html#termo:condicional aninhada">condicional aninhada</a></dt>
<dd>Uma instrução condicional que aparece em um dos ramos de outra instrução condicional.</dd>

<dt><a id="glos:instrução de retorno" href="05-cond-recur.html#termo:instrução de retorno">instrução de retorno</a></dt>
<dd>Uma instrução que faz uma função terminar imediatamente e voltar a quem a chamou.</dd>

<dt><a id="glos:recursividade" href="05-cond-recur.html#termo:recursividade">recursividade</a></dt>
<dd>O processo de chamar a função que está sendo executada no momento.</dd>

<dt><a id="glos:caso-base" href="05-cond-recur.html#termo:caso-base">caso-base</a></dt>
<dd>Um ramo condicional em uma função recursiva que não faz uma chamada recursiva.</dd>

<dt><a id="glos:recursividade infinita" href="05-cond-recur.html#termo:recursividade infinita">recursividade infinita</a></dt>
<dd>Recursividade que não tem um caso-base, ou nunca o atinge. A recursividade infinita eventualmente causa um erro em tempo de execução.</dd>

</dl>

<h2 id="514---exercícios">5.14 - Exercícios</h2>

<h3 id="exercício-51">Exercício 5.1</h3>

<p>O módulo time fornece uma função, também chamada time, que devolve a Hora Média de Greenwich na “época”, que é um momento arbitrário usado como ponto de referência. Em sistemas UNIX, a época é primeiro de janeiro de 1970.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">time</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="mf">1437746094.5735958</span>
</code></pre></div></div>

<p>Escreva um script que leia a hora atual e a converta em um tempo em horas, minutos e segundos, mais o número de dias desde a época.</p>

<h3 id="exercício-52">Exercício 5.2</h3>

<p>O último teorema de Fermat diz que não existem números inteiros a, b e c tais que <code class="highlighter-rouge">a**n + b**n == c**n</code> para quaisquer valores de n maiores que 2.</p>

<ol>
  <li>
    <p>Escreva uma função chamada check_fermat que receba quatro parâmetros – a, b, c e n – e verifique se o teorema de Fermat se mantém. Se n for maior que 2 e <code class="highlighter-rouge">a**n + b**n == c**n</code> o programa deve imprimir, “Holy smokes, Fermat was wrong!” Senão o programa deve exibir “No, that doesn’t work.”</p>
  </li>
  <li>
    <p>Escreva uma função que peça ao usuário para digitar valores para a, b, c e n, os converta em números inteiros e use check_fermat para verificar se violam o teorema de Fermat.</p>
  </li>
</ol>

<h3 id="exercício-53">Exercício 5.3</h3>

<p>Se você tiver três gravetos, pode ser que consiga arranjá-los em um triângulo ou não. Por exemplo, se um dos gravetos tiver 12 polegadas de comprimento e outros dois tiverem uma polegada de comprimento, não será possível fazer com que os gravetos curtos se encontrem no meio. Há um teste simples para ver se é possível formar um triângulo para quaisquer três comprimentos:</p>

<p>Se algum dos três comprimentos for maior que a soma dos outros dois, então você não pode formar um triângulo. Senão, você pode. (Se a soma de dois comprimentos igualar o terceiro, eles formam um triângulo chamado “degenerado”.)</p>

<ol>
  <li>
    <p>Escreva uma função chamada <code class="highlighter-rouge">is_triangle</code> que receba três números inteiros como argumentos, e que imprima “Yes” ou “No”, dependendo da possibilidade de formar ou não um triângulo de gravetos com os comprimentos dados.</p>
  </li>
  <li>
    <p>Escreva uma função que peça ao usuário para digitar três comprimentos de gravetos, os converta em números inteiros e use <code class="highlighter-rouge">is_triangle</code> para verificar se os gravetos com os comprimentos dados podem formar um triângulo.</p>
  </li>
</ol>

<h3 id="exercício-54">Exercício 5.4</h3>

<p>Qual é a saída do seguinte programa? Desenhe um diagrama da pilha que mostre o estado do programa quando exibir o resultado.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">recurse</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="n">s</span><span class="p">)</span>

<span class="n">recurse</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>
    <p>O que aconteceria se você chamasse esta função desta forma: recurse(-1, 0)?</p>
  </li>
  <li>
    <p>Escreva uma docstring que explique tudo o que alguém precisaria saber para usar esta função (e mais nada).</p>
  </li>
</ol>

<p>Os seguintes exercícios usam o módulo turtle, descrito no Capítulo 4:</p>

<h3 id="exercício-55">Exercício 5.5</h3>

<p>Leia a próxima função e veja se consegue compreender o que ela faz (veja os exemplos no Capítulo 4). Então execute-a e veja se acertou.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">angle</span> <span class="o">=</span> <span class="mi">50</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">t</span><span class="o">.</span><span class="n">fd</span><span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">t</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">draw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">t</span><span class="o">.</span><span class="n">rt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">draw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">t</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">t</span><span class="o">.</span><span class="n">bk</span><span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="exercício-56">Exercício 5.6</h3>

<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_0502.png" alt="Figura 5.2 – Uma curva de Koch." />
<br /><em>Figura 5.2 – Uma curva de Koch.</em></p>

<p>A curva de Koch é um fractal que parece com o da Figura 5.2. Para desenhar uma curva de Koch com o comprimento x, tudo o que você tem que fazer é:</p>

<ol>
  <li>
    <p>Desenhe uma curva de Koch com o comprimento x/3.</p>
  </li>
  <li>
    <p>Vire 60 graus à esquerda.</p>
  </li>
  <li>
    <p>Desenhe uma curva de Koch com o comprimento x/3.</p>
  </li>
  <li>
    <p>Vire 120 graus à direita.</p>
  </li>
  <li>
    <p>Desenhe uma curva de Koch com o comprimento x/3.</p>
  </li>
  <li>
    <p>Vire 60 graus à esquerda.</p>
  </li>
  <li>
    <p>Desenhe uma curva de Koch com o comprimento x/3.</p>
  </li>
</ol>

<p>A exceção é se x for menor que 3: neste caso, você pode desenhar apenas uma linha reta com o comprimento x.</p>

<ol>
  <li>
    <p>Escreva uma função chamada koch que receba um turtle e um comprimento como parâmetros, e use o turtle para desenhar uma curva de Koch com o comprimento dado.</p>
  </li>
  <li>
    <p>Escreva uma função chamada snowflake que desenhe três curvas de Koch para fazer o traçado de um floco de neve.</p>
  </li>
</ol>

<p>        Solução: http://thinkpython2.com/code/koch.py.</p>

<ol>
  <li>A curva de Koch pode ser generalizada de vários modos. Veja exemplos em http://en.wikipedia.org/wiki/Koch_snowflake e implemente o seu favorito.</li>
</ol>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/PenseAllen/PensePython2e">PensePython2e</a> is maintained by <a href="https://github.com/PenseAllen">PenseAllen</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
