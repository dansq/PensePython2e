<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Capítulo 17: Classes e métodos | PensePython2e</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Capítulo 17: Classes e métodos" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey" />
<meta property="og:description" content="Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey" />
<link rel="canonical" href="17-classes-metodos.html" />
<meta property="og:url" content="https://penseallen.github.io/PensePython2e/17-classes-metodos.html" />
<meta property="og:site_name" content="PensePython2e" />
<script type="application/ld+json">
{"@type":"WebPage","headline":"Capítulo 17: Classes e métodos","url":"https://penseallen.github.io/PensePython2e/17-classes-metodos.html","description":"Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link rel="stylesheet" href="assets/css/style.css@v=afa460130599dbde01620e86c38923f785023956.css">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">PensePython2e</h1>
      <h2 class="project-tagline">Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey</h2>
      
        <a href="https://github.com/PenseAllen/PensePython2e" class="btn">View on GitHub</a>
      
      
    </section>

    <section class="main-content">
      <h1 id="capítulo-17-classes-e-métodos">Capítulo 17: Classes e métodos</h1>

<p>Embora estejamos usando alguns recursos de orientação a objeto do Python, os programas dos dois últimos capítulos não são realmente orientados a objeto, porque não representam as relações entre os tipos definidos pelo programador e as funções que os produzem. O próximo passo é transformar essas funções em métodos que tornem as relações claras.</p>

<p>Os exemplos de código deste capítulo estão disponíveis em http://thinkpython2.com/code/Time2.py e as soluções para os exercícios estão em http://thinkpython2.com/code/Point2_soln.py.</p>

<h2 id="171---recursos-de-orientação-a-objeto">17.1 - Recursos de orientação a objeto</h2>

<p>Python é uma linguagem de programação orientada a objeto, ou seja, ela oferece recursos de programação orientada a objeto que tem a seguintes características:</p>

<ul>
  <li>
    <p>Os programas incluem definições de classes e métodos.</p>
  </li>
  <li>
    <p>A maior parte dos cálculos é expressa em termos de operações em objetos.</p>
  </li>
  <li>
    <p>Os objetos muitas vezes representam coisas no mundo real, e os métodos muitas vezes correspondem às formas em que as coisas no mundo real interagem.</p>
  </li>
</ul>

<p>Por exemplo, a classe <code class="highlighter-rouge">Time</code> definida no Capítulo 16 corresponde à forma como as pessoas registram a hora do dia, e as funções que definimos correspondem aos tipos de coisas que as pessoas fazem com os horários. De forma similar, as classes <code class="highlighter-rouge">Point</code> e <code class="highlighter-rouge">Rectangle</code> no Capítulo 15 correspondem aos conceitos matemáticos de ponto e retângulo.</p>

<p>Por enquanto, não aproveitamos os recursos que o Python oferece para programação orientada a objeto. Esses recursos não são estritamente necessários; a maioria deles oferece uma sintaxe alternativa para coisas que já fizemos. No entanto, em muitos casos, a alternativa é mais concisa e representa de forma mais exata a estrutura do programa.</p>

<p>Por exemplo, em <code class="highlighter-rouge">Time1.py</code> não há nenhuma conexão óbvia entre a definição de classe e as definições de função que seguem. Com um pouco de atenção, é evidente que cada função recebe pelo menos um objeto Time como argumento.</p>

<p>Essa observação é a motivação para usar métodos; um método é uma função associada a determinada classe. Vimos métodos de string, listas, dicionários e tuplas. Neste capítulo definiremos métodos para tipos definidos pelo programador.</p>

<p>Métodos são semanticamente o mesmo que funções, mas há duas diferenças sintáticas:</p>

<ul>
  <li>
    <p>Os métodos são definidos dentro de uma definição de classe para tornar clara a relação entre a classe e o método.</p>
  </li>
  <li>
    <p>A sintaxe para invocar um método é diferente da sintaxe para chamar uma função.</p>
  </li>
</ul>

<p>Nas próximas seções tomaremos as funções dos dois capítulos anteriores e as transformaremos em métodos. Essa transformação é puramente mecânica; você pode fazê-la seguindo uma série de passos. Se estiver à vontade para fazer a conversão entre uma forma e outra, sempre poderá escolher a melhor forma para contemplar os seus objetivos.</p>

<h2 id="172---exibição-de-objetos">17.2 - Exibição de objetos</h2>

<p>No Capítulo 16 definimos uma classe chamada Time em “Time”, na página 231, e você escreveu uma função denominada <code class="highlighter-rouge">print_time</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Time</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="s">"""Represents the time of day."""</span>

<span class="k">def</span> <span class="nf">print_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="si">%.2</span><span class="s">d:</span><span class="si">%.2</span><span class="s">d:</span><span class="si">%.2</span><span class="s">d'</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">second</span><span class="p">))</span>
</code></pre></div></div>

<p>Para chamar esta função, você precisa passar um objeto Time como argumento:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">start</span> <span class="o">=</span> <span class="n">Time</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">start</span><span class="o">.</span><span class="n">hour</span> <span class="o">=</span> <span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">start</span><span class="o">.</span><span class="n">minute</span> <span class="o">=</span> <span class="mi">45</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">start</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="mo">00</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="mi">09</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>Para fazer de <code class="highlighter-rouge">print_time</code> um método, tudo o que precisamos fazer é mover a definição da função para dentro da definição da classe. Note a alteração na endentação:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Time</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">print_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="si">%.2</span><span class="s">d:</span><span class="si">%.2</span><span class="s">d:</span><span class="si">%.2</span><span class="s">d'</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">second</span><span class="p">))</span>
</code></pre></div></div>

<p>Agora há duas formas de chamar <code class="highlighter-rouge">print_time</code>. A primeira forma (e menos comum) é usar a sintaxe de função:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">Time</span><span class="o">.</span><span class="n">print_time</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="mi">09</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>Nesse uso da notação de ponto, Time é o nome da classe, e <code class="highlighter-rouge">print_time</code> é o nome do método. <code class="highlighter-rouge">start</code> é passado como um parâmetro.</p>

<p>A segunda forma (e mais concisa) é usar a sintaxe de método:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">start</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="mi">09</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>Nesse uso da notação de ponto, <code class="highlighter-rouge">print_time</code> é o nome do método (novamente), e <code class="highlighter-rouge">start</code> é o objeto no qual o método é invocado, que se chama de sujeito. Assim como em uma sentença, onde o sujeito é o foco da escrita, o sujeito de uma invocação de método é o foco do método.</p>

<p>Dentro do método, o sujeito é atribuído ao primeiro parâmetro, portanto, neste caso, <code class="highlighter-rouge">start</code> é atribuído a <code class="highlighter-rouge">time</code>.</p>

<p>Por convenção, o primeiro parâmetro de um método chama-se <code class="highlighter-rouge">self</code>, então seria mais comum escrever <code class="highlighter-rouge">print_time</code> desta forma:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Time</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">print_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="si">%.2</span><span class="s">d:</span><span class="si">%.2</span><span class="s">d:</span><span class="si">%.2</span><span class="s">d'</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">))</span>
</code></pre></div></div>

<p>A razão dessa convenção é uma metáfora implícita:</p>

<ul>
  <li>
    <p>A sintaxe de uma chamada de função, <code class="highlighter-rouge">print_time(start)</code>, sugere que a função é o agente ativo. Ela diz algo como: “Ei, <code class="highlighter-rouge">print_time</code>! Aqui está um objeto para você exibir”.</p>
  </li>
  <li>
    <p>Na programação orientada a objeto, os objetos são os agentes ativos. Uma invocação de método <code class="highlighter-rouge">como start.print_time()</code> diz: “Ei, <code class="highlighter-rouge">start</code>! Por favor, exiba-se”.</p>
  </li>
</ul>

<p>Essa mudança de perspectiva pode ser mais polida, mas não é óbvio que seja útil. Nos exemplos que vimos até agora, pode não ser. Porém, às vezes, deslocar a responsabilidade das funções para os objetos permite escrever funções (ou métodos) mais versáteis e facilita a manutenção e reutilização do código.</p>

<p>Como exercício, reescreva <code class="highlighter-rouge">time_to_int</code> (de “Prototipação versus planejamento”, na página 234) como um método. Você pode ficar tentado a reescrever <code class="highlighter-rouge">int_to_time</code> como um método também, mas isso não faz muito sentido porque não haveria nenhum objeto sobre o qual invocá-lo.</p>

<h2 id="173---outro-exemplo">17.3 - Outro exemplo</h2>

<p>Aqui está uma versão de increment (de “Modificadores”, na página 233) reescrita como método:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Time:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">seconds</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">int_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
</code></pre></div></div>

<p>Essa versão assume que <code class="highlighter-rouge">time_to_int</code> seja escrita como método. Além disso, observe que é uma função pura, não um modificador.</p>

<p>É assim que eu invocaria increment:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">start</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="mi">09</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mo">00</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">end</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="mi">10</span><span class="p">:</span><span class="mo">07</span><span class="p">:</span><span class="mi">17</span>
</code></pre></div></div>

<p>O sujeito, start, é atribuído ao primeiro parâmetro, self. O argumento, 1337, é atribuído ao segundo parâmetro, seconds.</p>

<p>Esse mecanismo pode ser confuso, especialmente se você fizer um erro. Por exemplo, se invocar increment com dois argumentos, recebe:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="mi">460</span><span class="p">)</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">increment</span><span class="p">()</span> <span class="n">takes</span> <span class="mi">2</span> <span class="n">positional</span> <span class="n">arguments</span> <span class="n">but</span> <span class="mi">3</span> <span class="n">were</span> <span class="n">given</span>
</code></pre></div></div>

<p>A mensagem de erro é inicialmente confusa, porque há só dois argumentos entre parênteses. No entanto, o sujeito também é considerado um argumento, então, somando tudo, são três.</p>

<p>A propósito, um argumento posicional é o que não tem um nome de parâmetro; isto é, não é um argumento de palavra-chave. Nesta chamada da função:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sketch</span><span class="p">(</span><span class="n">parrot</span><span class="p">,</span> <span class="n">cage</span><span class="p">,</span> <span class="n">dead</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<p>parrot e cage são posicionais, e dead é um argumento de palavra-chave.</p>

<h2 id="174---um-exemplo-mais-complicado">17.4 - Um exemplo mais complicado</h2>

<p>Reescrever <code class="highlighter-rouge">is_after</code> (de “Time”, na página 231) é ligeiramente mais complicado, porque ela recebe dois objetos Time como parâmetros. Nesse caso, a convenção é denominar o primeiro parâmetro self e o segundo parâmetro other:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Time:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">is_after</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
</code></pre></div></div>

<p>Para usar este método, você deve invocá-lo para um objeto e passar outro como argumento:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">end</span><span class="o">.</span><span class="n">is_after</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>Uma vantagem desta sintaxe é que é quase literal em inglês: “o fim é depois da partida?”.</p>

<h2 id="175---método-init">17.5 - Método init</h2>

<p>O método <code class="highlighter-rouge">__init__</code> (abreviação da palavra em inglês para “inicialização”) é um método especial, invocado quando um objeto é instanciado. Seu nome completo é <code class="highlighter-rouge">__init__</code> (dois caracteres de sublinhado, seguidos de init, e mais dois sublinhados). Um método <code class="highlighter-rouge">__init__</code> da classe Time pode ser algo assim:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Time:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">hour</span> <span class="o">=</span> <span class="n">hour</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">minute</span> <span class="o">=</span> <span class="n">minute</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">second</span>
</code></pre></div></div>

<p>É comum que os parâmetros de <code class="highlighter-rouge">__init__</code> tenham os mesmos nomes que os atributos. A instrução</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">hour</span> <span class="o">=</span> <span class="n">hour</span>
</code></pre></div></div>

<p>guarda o valor do parâmetro <code class="highlighter-rouge">hour</code> como um atributo de <code class="highlighter-rouge">self</code>.</p>

<p>Os parâmetros são opcionais, então, se você chamar Time sem argumentos, recebe os valores padrão:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="mo">00</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>Se incluir um argumento, ele define hour.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span> <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>Se fornecer dois argumentos, hour e minute serão definidos:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time</span><span class="o">.</span><span class="n">print_time</span><span class="p">()</span>
<span class="mi">09</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>E se você fornecer três argumentos, os três valores serão definidos.</p>

<p>Como exercício, escreva um método init da classe Point que receba x e y como parâmetros opcionais e os relacione aos atributos correspondentes.</p>

<h2 id="176---método-__str__">17.6 - Método <code class="highlighter-rouge">__str__</code></h2>

<p><code class="highlighter-rouge">__str__</code> é um método especial, como <code class="highlighter-rouge">__init__</code>, usado para retornar uma representação de string de um objeto.</p>

<p>Por exemplo, aqui está um método str para objetos Time:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Time:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="s">'</span><span class="si">%.2</span><span class="s">d:</span><span class="si">%.2</span><span class="s">d:</span><span class="si">%.2</span><span class="s">d'</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
</code></pre></div></div>

<p>Ao exibir um objeto com print, o Python invoca o método str:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
<span class="mi">09</span><span class="p">:</span><span class="mi">45</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>Quando escrevo uma nova classe, quase sempre começo escrevendo <code class="highlighter-rouge">__init__</code>, o que facilita a instanciação de objetos, e <code class="highlighter-rouge">__str__</code>, que é útil para a depuração.</p>

<p>Como exercício, escreva um método str da classe Point. Crie um objeto Point e exiba-o.</p>

<h2 id="177---sobrecarga-de-operadores">17.7 - Sobrecarga de operadores</h2>

<p>Ao definir outros métodos especiais, você pode especificar o comportamento de operadores nos tipos definidos pelo programador. Por exemplo, se você definir um método chamado <code class="highlighter-rouge">__add__</code> para a classe Time de Time, pode usar o operador + em objetos Time.</p>

<p>A definição pode ser assim:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Time:</span>

  <span class="err"> </span> <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">seconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">int_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
</code></pre></div></div>

<p>Você pode usá-lo assim:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">start</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">duration</span><span class="p">)</span>
<span class="mi">11</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>Ao aplicar o operador + a objetos Time, o Python invoca <code class="highlighter-rouge">__add__</code>. Ao exibir o resultado, o Python invoca <code class="highlighter-rouge">__str__</code>. Ou seja, há muita coisa acontecendo nos bastidores!</p>

<p>Alterar o comportamento de um operador para que funcione com tipos definidos pelo programador chama-se sobrecarga de operadores. Para cada operador no Python há um método especial correspondente, como <code class="highlighter-rouge">__add__</code>. Para obter mais informações, veja http://docs.python.org/3/reference/datamodel.html#specialnames.</p>

<p>Como exercício, escreva um método add para a classe Point.</p>

<h2 id="178---despacho-por-tipo">17.8 - Despacho por tipo</h2>

<p>Na seção anterior, acrescentamos dois objetos Time, mas você também pode querer acrescentar um número inteiro a um objeto Time. A seguir, veja uma versão de <code class="highlighter-rouge">__add__</code>, que verifica o tipo de other e invoca <code class="highlighter-rouge">add_time</code> ou increment:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Time:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_time</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">add_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">seconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">int_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seconds</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">seconds</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_to_int</span><span class="p">()</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">int_to_time</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
</code></pre></div></div>

<p>A função construída isinstance recebe um valor e um objeto de classe e retorna True se o valor for uma instância da classe.</p>

<p>Se other for um objeto Time, <code class="highlighter-rouge">__add__</code> invoca <code class="highlighter-rouge">add_time</code>. Do contrário, assume que o parâmetro seja um número e invoca increment. Essa operação chama-se despacho por tipo porque despacha a operação a métodos diferentes, baseados no tipo dos argumentos.</p>

<p>Veja exemplos que usam o operador <code class="highlighter-rouge">+</code> com tipos diferentes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">start</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">45</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">duration</span><span class="p">)</span>
<span class="mi">11</span><span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mo">00</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1337</span><span class="p">)</span>
<span class="mi">10</span><span class="p">:</span><span class="mo">07</span><span class="p">:</span><span class="mi">17</span>
</code></pre></div></div>

<p>Infelizmente, esta implementação da adição não é comutativa. Se o número inteiro for o primeiro operando, você recebe</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="mi">1337</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">unsupported</span> <span class="n">operand</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="o">+</span><span class="p">:</span> <span class="s">'int'</span> <span class="ow">and</span> <span class="s">'instance'</span>
</code></pre></div></div>

<p>O problema é que, em vez de pedir ao objeto Time que adicione um número inteiro, o Python está pedindo que um número inteiro adicione um objeto Time, e ele não sabe como fazer isso. Entretanto, há uma solução inteligente para este problema: o método especial <code class="highlighter-rouge">__radd__</code>, que significa “adição à direita”. Esse método é invocado quando um objeto Time aparece no lado direito do operador +. Aqui está a definição:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Time:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
</code></pre></div></div>

<p>E é assim que ele é usado:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="mi">1337</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
<span class="mi">10</span><span class="p">:</span><span class="mo">07</span><span class="p">:</span><span class="mi">17</span>
</code></pre></div></div>

<p>Como exercício, escreva um método add para Points que funcione com um objeto Point ou com uma tupla:</p>

<ul>
  <li>
    <p>Se o segundo operando for um Point, o método deve retornar um novo Point cuja coordenada x é a soma das coordenadas x dos operandos, e o mesmo se aplica às coordenadas de y.</p>
  </li>
  <li>
    <p>Se o segundo operando for uma tupla, o método deve adicionar o primeiro elemento da tupla à coordenada de x e o segundo elemento à coordenada de y, retornando um novo Point com o resultado.</p>
  </li>
</ul>

<h2 id="179---polimorfismo">17.9 - Polimorfismo</h2>

<p>O despacho por tipo é útil, mas (felizmente) nem sempre é necessário. Muitas vezes, você pode evitá-lo escrevendo funções que funcionem corretamente para argumentos de tipos diferentes.</p>

<p>Muitas das funções que escrevemos para strings também funcionam para outros tipos de sequência. Por exemplo, em “Um dicionário como uma coleção de contadores”, na página 163, usamos histogram para contar o número de vezes que cada letra aparece numa palavra:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">d</span>
</code></pre></div></div>

<p>Essa função também funciona com listas, tuplas e até dicionários, desde que os elementos de s sejam hashable, então eles podem ser usados como chaves em d:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="s">'spam'</span><span class="p">,</span> <span class="s">'egg'</span><span class="p">,</span> <span class="s">'spam'</span><span class="p">,</span> <span class="s">'spam'</span><span class="p">,</span> <span class="s">'bacon'</span><span class="p">,</span> <span class="s">'spam'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">histogram</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span><span class="s">'bacon'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'egg'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'spam'</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></div></div>
<p>As funções que funcionam com vários tipos chamam-se polimórficas. O polimorfismo pode facilitar a reutilização do código. Por exemplo, a função integrada sum, que adiciona os elementos de uma sequência, funciona só se os elementos da sequência forem compatíveis com adição.</p>

<p>Como os objetos Time oferecem o método add, eles funcionam com sum:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">43</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">41</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t3</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">37</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
<span class="mi">23</span><span class="p">:</span><span class="mo">01</span><span class="p">:</span><span class="mo">00</span>
</code></pre></div></div>

<p>Em geral, se todas as operações dentro de uma função forem compatíveis com um dado tipo, não haverá problemas.</p>

<p>O melhor tipo de polimorfismo é o não intencional, quando você descobre que uma função que já escreveu pode ser aplicada a um tipo para o qual ela não tinha planejada.</p>

<h2 id="1710---interface-e-implementação">17.10 - Interface e implementação</h2>

<p>Uma das metas do projeto orientado a objeto é facilitar a manutenção do programa, para que você possa mantê-lo funcionando quando outras partes do sistema forem alteradas, e também poder alterar o programa para satisfazer novas condições.</p>

<p>Um princípio de projeto que ajuda a atingir essa meta é manter as interfaces separadas das implementações. Para objetos, isso quer dizer que os métodos que uma classe oferece não devem depender de como os atributos são representados.</p>

<p>Por exemplo, neste capítulo desenvolvemos uma classe que representa uma hora do dia. Os métodos fornecidos por esta classe incluem time_to_int, is_after e add_time.</p>

<p>Podemos implementar esses métodos de várias formas. Os detalhes da implementação dependem de como representamos as horas. Neste capítulo, os atributos de um objeto Time são hour, minute e second.</p>

<p>Como alternativa, podemos substituir esses atributos por um número inteiro único que represente o número de segundos desde a meia-noite. Essa implementação faria com que alguns métodos, como is_after, fossem mais fáceis de escrever, mas dificultaria o uso de outros métodos.</p>

<p>Pode acontecer que, depois de implementar uma nova classe, você descubra uma implementação melhor. Se outras partes do programa estiverem usando a sua classe, mudar a interface pode ser trabalhoso e induzir a erros.</p>

<p>No entanto, se projetou a interface cuidadosamente, pode alterar a implementação sem mudar a interface, e não será preciso mudar outras partes do programa.</p>

<h2 id="1711---depuração">17.11 - Depuração</h2>

<p>É legal acrescentar atributos a objetos em qualquer ponto da execução de um programa, mas se você tiver objetos do mesmo tipo que não têm os mesmos atributos, é fácil cometer erros. É uma boa ideia inicializar todos os atributos de um objeto no método init.</p>

<p>Caso não tenha certeza se um objeto tem um determinado atributo, você pode usar a função integrada hasattr (ver “Depuração”, na página 236).</p>

<p>Outra forma de acessar atributos é com a função integrada vars, que recebe um objeto e retorna um dicionário que mapeia os nomes dos atributos (como strings) aos seus valores:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">vars</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span><span class="s">'y'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s">'x'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

<p>Para facilitar a depuração, pode ser útil usar esta função:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_attributes</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">print</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">print_attributes</code> atravessa o dicionário e imprime cada nome de atributo e o seu valor correspondente.</p>

<p>A função integrada getattr recebe um objeto e um nome de atributo (como uma string) e devolve o valor do atributo.</p>

<h2 id="1712---glossário">17.12 - Glossário</h2>

<dl>
<dt><a id="glos:linguagem orientada a objeto" href="17-classes-metodos.html#termo:linguagem orientada a objeto">linguagem orientada a objeto</a></dt>
<dd>Linguagem que fornece recursos, como tipos definidos pelo programador e métodos, que facilitam a programação orientada a objeto.</dd>

<dt><a id="glos:programação orientada a objeto" href="17-classes-metodos.html#termo:programação orientada a objeto">programação orientada a objeto</a></dt>
<dd>Estilo de programação na qual os dados e as operações que os manipulam são organizadas em classes e métodos.</dd>

<dt><a id="glos:método" href="17-classes-metodos.html#termo:método">método</a></dt>
<dd>Função criada dentro de uma definição de classe e invocada em instâncias desta classe.</dd>

<dt><a id="glos:sujeito" href="17-classes-metodos.html#termo:sujeito">sujeito</a></dt>
<dd>Objeto sobre o qual um método é invocado.</dd>

<dt><a id="glos:argumento posicional" href="17-classes-metodos.html#termo:argumento posicional">argumento posicional</a></dt>
<dd>Argumento que não inclui um nome de parâmetro, portanto não é um argumento de palavra-chave.</dd>

<dt><a id="glos:sobrecarga de operador" href="17-classes-metodos.html#termo:sobrecarga de operador">sobrecarga de operador</a></dt>
<dd>Alteração do comportamento de um operador como + para que funcione com um tipo definido pelo programador.</dd>

<dt><a id="glos:despacho por tipo" href="17-classes-metodos.html#termo:despacho por tipo">despacho por tipo</a></dt>
<dd>Modelo de programação que invoca funções diferentes dependendo do tipo do operando.</dd>

<dt><a id="glos:polimórfico" href="17-classes-metodos.html#termo:polimórfico">polimórfico</a></dt>
<dd>Pertinente a uma função que pode funcionar com mais de um tipo.</dd>

<dt><a id="glos:ocultamento de informação" href="17-classes-metodos.html#termo:ocultamento de informação">ocultamento de informação</a></dt>
<dd>Princípio segundo o qual a interface fornecida por um objeto não deve depender da sua implementação, especialmente em relação à representação dos seus atributos.</dd>

</dl>

<h2 id="1713---exercícios">17.13 - Exercícios</h2>

<h3 id="exercício-171">Exercício 17.1</h3>

<p>Baixe o código deste capítulo em http://thinkpython2.com/code/Time2.py. Altere os atributos de Time para que um número inteiro único represente os segundos decorridos desde a meia-noite. Então altere os métodos (e a função int_to_time) para funcionar com a nova implementação. Você não deve modificar o código de teste em main. Ao terminar, a saída deve ser a mesma que antes.</p>

<p>Solução: http://thinkpython2.com/code/Time2_soln.py.</p>

<h3 id="exercício-172">Exercício 17.2</h3>

<p>Este exercício é uma história com moral sobre um dos erros mais comuns e difíceis de encontrar no Python. Escreva uma definição de classe chamada Kangaroo com os seguintes métodos:</p>

<ol>
  <li>
    <p>Um método <code class="highlighter-rouge">__init__</code> que inicialize um atributo chamado <code class="highlighter-rouge">pouch_contents</code>  em uma lista vazia.</p>
  </li>
  <li>
    <p>Um método chamado <code class="highlighter-rouge">put_in_pouch</code> que receba um objeto de qualquer tipo e o acrescente a <code class="highlighter-rouge">pouch_contents</code>.</p>
  </li>
  <li>
    <p>Um método <code class="highlighter-rouge">__str__</code> que retorne uma representação de string do objeto Kangaroo e os conteúdos de pouch (bolsa).</p>
  </li>
</ol>

<p>Teste o seu código criando dois objetos Kangaroo, atribuindo-os a variáveis chamadas kanga e roo, e então acrescentando roo ao conteúdo da bolsa de kanga.</p>

<p>Baixe http://thinkpython2.com/code/BadKangaroo.py. Ele contém uma solução para o problema anterior com um defeito bem grande e bem feio. Encontre e corrija o defeito.</p>

<p>Se não conseguir achar a solução, você pode baixar http://thinkpython2.com/code/GoodKangaroo.py, que explica o problema e demonstra uma solução.</p>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/PenseAllen/PensePython2e">PensePython2e</a> is maintained by <a href="https://github.com/PenseAllen">PenseAllen</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
