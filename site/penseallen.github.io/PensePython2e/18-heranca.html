<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Capítulo 18: Herança | PensePython2e</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Capítulo 18: Herança" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey" />
<meta property="og:description" content="Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey" />
<link rel="canonical" href="18-heranca.html" />
<meta property="og:url" content="https://penseallen.github.io/PensePython2e/18-heranca.html" />
<meta property="og:site_name" content="PensePython2e" />
<script type="application/ld+json">
{"@type":"WebPage","headline":"Capítulo 18: Herança","url":"https://penseallen.github.io/PensePython2e/18-heranca.html","description":"Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link rel="stylesheet" href="assets/css/style.css@v=afa460130599dbde01620e86c38923f785023956.css">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">PensePython2e</h1>
      <h2 class="project-tagline">Tradução do livro Pense em Python (2ª ed.), de Allen B. Downey</h2>
      
        <a href="https://github.com/PenseAllen/PensePython2e" class="btn">View on GitHub</a>
      
      
    </section>

    <section class="main-content">
      <h1 id="capítulo-18-herança">Capítulo 18: Herança</h1>

<p>O termo mais associado com a programação orientada a objeto é herança. A herança é a capacidade de definir uma nova classe que seja uma versão modificada de uma classe existente. Neste capítulo demonstrarei a herança usando classes que representam jogos de cartas, baralhos e mãos de pôquer.</p>

<p>Se você não joga pôquer, pode ler sobre ele em http://en.wikipedia.org/wiki/Poker, mas não é necessário; vou dizer tudo o que precisa saber para os exercícios.</p>

<p>Os exemplos de código deste capítulo estão disponíveis em http://thinkpython2.com/code/Card.py.</p>

<h2 id="181---objetos-card">18.1 - Objetos Card</h2>

<p>Há 52 cartas em um baralho, e cada uma pertence a 1 dos 4 naipes e a 1 dos 13 valores. Os naipes são espadas, copas, ouros e paus (no bridge, em ordem descendente). A ordem dos valores é ás, 2, 3, 4, 5, 6, 7, 8, 9, 10, valete, dama e rei. Dependendo do jogo que estiver jogando, um ás pode ser mais alto que o rei ou mais baixo que 2.</p>

<p>Se quiséssemos definir um novo objeto para representar uma carta de jogo, os atributos óbvios seriam rank (valor) e suit (naipe). Mas não é tão óbvio qual tipo de atributo deveriam ser. Uma possibilidade é usar strings com palavras como ‘Spade’ (Espadas) para naipes e ‘Queen’ (Dama) para valores. Um problema com esta implementação é que não seria fácil comparar cartas para ver qual valor ou naipe tem classificação mais alta em relação aos outros.</p>

<p>Uma alternativa é usar números inteiros para codificar os valores e os naipes. Neste contexto, “codificar” significa que vamos definir um mapeamento entre números e naipes, ou entre números e valores. Este tipo de codificação não tem nada a ver com criptografia.</p>

<p>Por exemplo, esta tabela mostra os naipes e os códigos de número inteiro correspondentes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Spades (Espadas)     ↦ 3
Hearts (Copas)       ↦ 2
Diamonds (Ouros)     ↦ 1
Clubs (Paus)         ↦ 0
</code></pre></div></div>

<p>Este código facilita a comparação entre as cartas; como naipes mais altos mapeiam a números mais altos, podemos comparar naipes aos seus códigos.</p>

<p>O mapeamento de valores é até óbvio; cada um dos valores numéricos é mapeado ao número inteiro correspondente, e para cartas com figuras:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Jack (Valete)       ↦ 11
Queen (Dama)        ↦ 12
King (Rei)          ↦ 13
</code></pre></div></div>

<p>Estou usando o símbolo <code class="highlighter-rouge">↦</code> para deixar claro que esses mapeamentos não são parte do programa em Python. Eles são parte do projeto do programa, mas não aparecem explicitamente no código.</p>

<p>A definição de classe para Card (carta) é assim:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Card</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="s">"""Represents a standard playing card."""</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">=</span> <span class="n">suit</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="n">rank</span>
</code></pre></div></div>

<p>Como sempre, o método <code class="highlighter-rouge">__init__</code> recebe um parâmetro opcional de cada atributo. A carta padrão é 2 de paus.</p>

<p>Para criar um Card, você chama Card com o naipe e valor desejados:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">queen_of_diamonds</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="182---atributos-de-classe">18.2 - Atributos de classe</h2>

<p>Para exibir objetos Card de uma forma que as pessoas possam ler com facilidade, precisamos de um mapeamento dos códigos de número inteiro aos naipes e valores correspondentes. Uma forma natural de fazer isso é com listas de strings. Atribuímos essas listas a atributos de classe:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Card:</span>

<span class="err"> </span> <span class="err"> </span> <span class="n">suit_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">'Clubs'</span><span class="p">,</span> <span class="s">'Diamonds'</span><span class="p">,</span> <span class="s">'Hearts'</span><span class="p">,</span> <span class="s">'Spades'</span><span class="p">]</span>
<span class="err"> </span> <span class="err"> </span> <span class="n">rank_names</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="s">'Ace'</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'3'</span><span class="p">,</span> <span class="s">'4'</span><span class="p">,</span> <span class="s">'5'</span><span class="p">,</span> <span class="s">'6'</span><span class="p">,</span> <span class="s">'7'</span><span class="p">,</span>
    <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="s">'8'</span><span class="p">,</span> <span class="s">'9'</span><span class="p">,</span> <span class="s">'10'</span><span class="p">,</span> <span class="s">'Jack'</span><span class="p">,</span> <span class="s">'Queen'</span><span class="p">,</span> <span class="s">'King'</span><span class="p">]</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="s">'</span><span class="si">%</span><span class="s">s of </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">Card</span><span class="o">.</span><span class="n">rank_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">],</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span><span class="n">Card</span><span class="o">.</span><span class="n">suit_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">suit</span><span class="p">])</span>
</code></pre></div></div>

<p>Variáveis como <code class="highlighter-rouge">suit_names</code> e <code class="highlighter-rouge">rank_names</code>, que são definidas dentro de uma classe, mas fora de qualquer método, chamam-se atributos de classe porque são associadas com o objeto de classe Card.</p>

<p>Este termo as distingue de variáveis como <code class="highlighter-rouge">suit</code> e <code class="highlighter-rouge">rank</code>, chamadas de atributos de instância porque são associados com determinada instância.</p>

<p>Ambos os tipos de atributo são acessados usando a notação de ponto. Por exemplo, em <code class="highlighter-rouge">__str__</code>, <code class="highlighter-rouge">self</code> é um objeto <code class="highlighter-rouge">Card</code>, e <code class="highlighter-rouge">self.rank</code> é o seu valor. De forma semelhante, Card é um objeto de classe, e <code class="highlighter-rouge">Card.rank_names</code> é uma lista de strings associadas à essa classe.</p>

<p>Cada carta tem seu próprio suit e rank, mas há só uma cópia de suit_names e rank_names.</p>

<p>Juntando tudo, a expressão <code class="highlighter-rouge">Card.rank_names[self.rank]</code> significa “use o rank (valor) do atributo do objeto self como um índice na lista rank_names da classe Card e selecione a string adequada”.</p>

<p>O primeiro elemento de rank_names é None, porque não há nenhuma carta com valor zero. Incluindo None para ocupar uma variável, conseguimos fazer um belo mapeamento onde o índice 2 é associado à string ‘2’, e assim por diante. Para evitar ter que usar esse truque, poderíamos usar um dicionário em vez de uma lista.</p>

<p>Com os métodos que temos por enquanto, podemos criar e exibir cartas:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">card1</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">card1</span><span class="p">)</span>
<span class="n">Jack</span> <span class="n">of</span> <span class="n">Hearts</span>
</code></pre></div></div>

<p>A Figura 18.1 é um diagrama do objeto de classe Card e uma instância de Card. Card é um objeto de classe; seu tipo é type. card1 é uma instância de Card, então seu tipo é Card. Para economizar espaço, não incluí o conteúdo de suit_names e rank_names.</p>

<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_1801.png" alt="Figura 18.1 – Diagrama de objetos: classe Card e card1, uma instância de Card." />
<br /><em>Figura 18.1 – Diagrama de objetos: classe</em> <code class="highlighter-rouge">Card</code> <em>e</em> <code class="highlighter-rouge">card1</code>, <em>uma instância de</em> <code class="highlighter-rouge">Card</code>.</p>

<h2 id="183---comparação-de-cartas">18.3 - Comparação de cartas</h2>

<p>Para tipos integrados, há operadores relacionais (<code class="highlighter-rouge">&lt;</code>, <code class="highlighter-rouge">&gt;</code>, <code class="highlighter-rouge">==</code> etc.) que comparam valores e determinam quando um é maior, menor ou igual a outro. Para tipos definidos pelo programador, podemos ignorar o comportamento dos operadores integrados fornecendo um método denominado <code class="highlighter-rouge">__lt__</code>, que representa “menos que”.</p>

<p><code class="highlighter-rouge">__lt__</code> recebe dois parâmetros, <code class="highlighter-rouge">self</code> e <code class="highlighter-rouge">other</code>, e <code class="highlighter-rouge">True</code> se self for estritamente menor que <code class="highlighter-rouge">other</code>.</p>

<p>A ordem correta das cartas não é óbvia. Por exemplo, qual é melhor, o 3 de paus ou o 2 de ouros? Uma tem o valor mais alto, mas a outra tem um naipe mais alto. Para comparar cartas, é preciso decidir o que é mais importante, o valor ou o naipe.</p>

<p>A resposta pode depender de que jogo você está jogando, mas, para manter a simplicidade, vamos fazer a escolha arbitrária de que o naipe é mais importante, então todas as cartas de espadas são mais importantes que as de ouros, e assim por diante.</p>

<p>Com isto decidido, podemos escrever <code class="highlighter-rouge">__lt__</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Card:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c"># conferir os naipes</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">suit</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">suit</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c"># os naipes são os mesmos... conferir valores</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span>
</code></pre></div></div>

<p>Você pode escrever isso de forma mais concisa usando uma comparação de tuplas:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Card:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">t2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">suit</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">t1</span> <span class="o">&lt;</span> <span class="n">t2</span>
</code></pre></div></div>

<p>Como exercício, escreva um método <code class="highlighter-rouge">__lt__</code> para objetos Time. Você pode usar uma comparação de tuplas, mas também pode usar a comparação de números inteiros.</p>

<h2 id="184---baralhos">18.4 - Baralhos</h2>

<p>Agora que temos Card, o próximo passo é definir Deck (baralho). Como um baralho é composto de cartas, é natural que um baralho contenha uma lista de cartas como atributo.</p>

<p>Veja a seguir uma definição de classe para <code class="highlighter-rouge">Deck</code>. O método init cria o atributo cards e gera o conjunto padrão de 52 cartas:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Deck</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="n">suit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">suit</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
</code></pre></div></div>

<p>A forma mais fácil de preencher o baralho é com um loop aninhado. O loop exterior enumera os naipes de 0 a 3. O loop interior enumera os valores de 1 a 13. Cada iteração cria um novo Card com o naipe e valor atual, e a acrescenta a self.cards.</p>

<h2 id="185---exibição-do-baralho">18.5 - Exibição do baralho</h2>

<p>Aqui está um método <strong>str</strong> para Deck:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Deck:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">card</span><span class="p">))</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</code></pre></div></div>

<p>Este método demonstra uma forma eficiente de acumular uma string grande: a criação de uma lista de strings e a utilização do método de string join. A função integrada str invoca o método <code class="highlighter-rouge">__str__</code> em cada carta e retorna a representação da string.</p>

<p>Como invocamos join em um caractere newline, as cartas são separadas por quebras de linha. O resultado é esse:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">deck</span> <span class="o">=</span> <span class="n">Deck</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">deck</span><span class="p">)</span>
<span class="n">Ace</span> <span class="n">of</span> <span class="n">Clubs</span>
<span class="mi">2</span> <span class="n">of</span> <span class="n">Clubs</span>
<span class="mi">3</span> <span class="n">of</span> <span class="n">Clubs</span>
<span class="o">...</span>
<span class="mi">10</span> <span class="n">of</span> <span class="n">Spades</span>
<span class="n">Jack</span> <span class="n">of</span> <span class="n">Spades</span>
<span class="n">Queen</span> <span class="n">of</span> <span class="n">Spades</span>
<span class="n">King</span> <span class="n">of</span> <span class="n">Spades</span>
</code></pre></div></div>

<p>Embora o resultado apareça em 52 linhas, na verdade ele é uma string longa com quebras de linha.</p>

<h2 id="186---adição-remoção-embaralhamento-e-classificação">18.6 - Adição, remoção, embaralhamento e classificação</h2>

<p>Para lidar com as cartas, gostaríamos de ter um método que removesse uma carta do baralho e a devolvesse. O método de lista pop oferece uma forma conveniente de fazer isso:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Deck:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">pop_card</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div></div>

<p>Como pop retira a última carta na lista, estamos lidando com o fundo do baralho.</p>

<p>Para adicionar uma carta, podemos usar o método de lista append:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Deck:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">add_card</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
</code></pre></div></div>

<p>Um método como esse, que usa outro método sem dar muito trabalho, às vezes é chamado de folheado. A metáfora vem do trabalho em madeira, onde o folheado é uma camada fina de madeira de boa qualidade colada à superfície de uma madeira mais barata para melhorar a aparência.</p>

<p>Nesse caso, <code class="highlighter-rouge">add_card</code> é um método “fino” que expressa uma operação de lista em termos adequados a baralhos. Ele melhora a aparência ou interface da implementação.</p>

<p>Em outro exemplo, podemos escrever um método Deck denominado shuffle, usando a função shuffle do módulo random:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Deck:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">)</span>
</code></pre></div></div>

<p>Não se esqueça de importar random.</p>

<p>Como exercício, escreva um método de Deck chamado sort, que use o método de lista sort para classificar as cartas em um Deck. sort usa o método <code class="highlighter-rouge">__lt__</code> que definimos para determinar a ordem.</p>

<h2 id="187---herança">18.7 - Herança</h2>

<p>A herança é a capacidade de definir uma nova classe que seja uma versão modificada de uma classe existente. Como exemplo, digamos que queremos que uma classe represente uma “mão”, isto é, as cartas mantidas por um jogador. Uma mão é semelhante a um baralho: ambos são compostos por uma coleção de cartas, e ambos exigem operações como adicionar e remover cartas.</p>

<p>Uma mão também é diferente de um baralho; há operações que queremos para mãos que não fazem sentido para um baralho. Por exemplo, no pôquer poderíamos comparar duas mãos para ver qual ganha. No bridge, poderíamos calcular a pontuação de uma mão para fazer uma aposta.</p>

<p>Essa relação entre classes – semelhante, mas diferente – adequa-se à herança. Para definir uma nova classe que herda algo de uma classe existente, basta colocar o nome da classe existente entre parênteses:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Hand</span><span class="p">(</span><span class="n">Deck</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="s">"""Represents a hand of playing cards."""</span>
</code></pre></div></div>

<p>Esta definição indica que Hand herda de Deck; isso significa que podemos usar métodos como pop_card e add_card para Hand bem como para Deck.</p>

<p>Quando uma nova classe herda de uma existente, a existente chama-se pai e a nova classe chama-se filho.</p>

<p>Neste exemplo, Hand herda <code class="highlighter-rouge">__init__</code> de Deck, mas na verdade não faz o que queremos: em vez de preencher a mão com 52 cartas novas, o método init de Hand deve inicializar card com uma lista vazia.</p>

<p>Se fornecermos um método init na classe Hand, ele ignora o da classe Deck:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Hand:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
</code></pre></div></div>

<p>Ao criar Hand, o Python invoca este método init, não o de Deck.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">hand</span> <span class="o">=</span> <span class="n">Hand</span><span class="p">(</span><span class="s">'new hand'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hand</span><span class="o">.</span><span class="n">cards</span>
<span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hand</span><span class="o">.</span><span class="n">label</span>
<span class="s">'new hand'</span>
</code></pre></div></div>

<p>Outros métodos são herdados de Deck, portanto podemos usar <code class="highlighter-rouge">pop_card</code> e <code class="highlighter-rouge">add_card</code> para lidar com uma carta:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">deck</span> <span class="o">=</span> <span class="n">Deck</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">card</span> <span class="o">=</span> <span class="n">deck</span><span class="o">.</span><span class="n">pop_card</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">hand</span><span class="o">.</span><span class="n">add_card</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">hand</span><span class="p">)</span>
<span class="n">King</span> <span class="n">of</span> <span class="n">Spades</span>
</code></pre></div></div>

<p>Um próximo passo natural seria encapsular este código em um método chamado <code class="highlighter-rouge">move_cards</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># dentro da classe Deck:</span>

<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">move_cards</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hand</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">hand</span><span class="o">.</span><span class="n">add_card</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop_card</span><span class="p">())</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">move_cards</code> recebe dois argumentos, um objeto Hand e o número de cartas com que vai lidar. Ele altera tanto self como hand e retorna None.</p>

<p>Em alguns jogos, as cartas são movidas de uma mão a outra, ou de uma mão de volta ao baralho. É possível usar <code class="highlighter-rouge">move_cards</code> para algumas dessas operações: self pode ser um Deck ou Hand, e hand, apesar do nome, também pode ser um Deck.</p>

<p>A herança é um recurso útil. Alguns programas que poderiam ser repetitivos sem herança podem ser escritos de forma mais elegante com ela. A herança pode facilitar a reutilização de código, já que você pode personalizar o comportamento de classes pais sem ter que alterá-las. Em alguns casos, a estrutura de herança reflete a estrutura natural do problema, o que torna o projeto mais fácil de entender.</p>

<p>De outro lado, a herança pode tornar os programas difíceis de ler. Quando um método é invocado, às vezes não está claro onde encontrar sua definição. O código relevante pode ser espalhado por vários módulos. Além disso, muitas das coisas que podem ser feitas usando a herança podem ser feitas sem elas, às vezes, até de forma melhor.</p>

<h2 id="188---diagramas-de-classe">18.8 - Diagramas de classe</h2>

<p>Por enquanto vimos diagramas de pilha, que mostram o estado de um programa e diagramas de objeto, que mostram os atributos de um objeto e seus valores. Esses diagramas representam um retrato da execução de um programa, então eles mudam no decorrer da execução do programa.</p>

<p>Eles também são altamente detalhados; para alguns objetivos, detalhados demais. Um diagrama de classe é uma representação mais abstrata da estrutura de um programa. Em vez de mostrar objetos individuais, ele mostra classes e as relações entre elas.</p>

<p>Há vários tipos de relações entre as classes:</p>

<ul>
  <li>
    <p>Os objetos de uma classe podem conter referências a objetos em outra classe. Por exemplo, cada Rectangle contém uma referência a um Point, e cada Deck contém referências a muitos Cards. Esse tipo de relação chama-se composição. É uma relação do tipo HAS-A (tem um), com a ideia de “um Rectangle tem um Point”.</p>
  </li>
  <li>
    <p>Uma classe pode herdar de outra. Esta relação chama-se IS-A (é um), com a ideia de “um Hand é um tipo de Deck”.</p>
  </li>
  <li>
    <p>Uma classe pode depender de outra no sentido de que os objetos em uma classe possam receber objetos na segunda classe como parâmetros ou usar esses objetos como parte de um cálculo. Este tipo de relação chama-se dependência.</p>
  </li>
</ul>

<p>Um diagrama de classe é uma representação gráfica dessas relações. Por exemplo, a Figura 18.2 mostra as relações entre Card, Deck e Hand.</p>

<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_1802.png" alt="Figura 18.2 – Diagrama de classes." />
<br /><em>Figura 18.2 – Diagrama de classes.</em></p>

<p>A flecha com um triângulo oco representa uma relação IS-A; nesse caso, indica que Hand herda de Deck.</p>

<p>A ponta de flecha padrão representa uma relação HAS-A; nesse caso, um Deck tem referências a objetos Card.</p>

<p>A estrela <strong>*</strong>  perto da ponta de flecha indica a multiplicidade; ela indica quantos Cards um Deck tem. Uma multiplicidade pode ser um número simples como 52, um intervalo como 5..7 ou uma estrela, que indica que um Deck pode ter qualquer número de Cards.</p>

<p>Não há nenhuma dependência neste diagrama. Elas normalmente apareceriam com uma flecha tracejada. Ou, se houver muitas dependências, às vezes elas são omitidas.</p>

<p>Um diagrama mais detalhado poderia mostrar que um Deck na verdade contém uma lista de Cards, mas os tipos integrados como lista e dict não são normalmente incluídos em diagramas de classe.</p>

<h2 id="189---encapsulamento-de-dados">18.9 - Encapsulamento de dados</h2>

<p>Os capítulos anteriores demonstram um plano de desenvolvimento que poderíamos chamar de “projeto orientado a objeto”. Identificamos os objetos de que precisamos – como Point, Rectangle e Time – e definimos classes para representá-los. Em cada caso há uma correspondência óbvia entre o objeto e alguma entidade no mundo real (ou, pelo menos, no mundo matemático).</p>

<p>Mas, às vezes, é menos óbvio quais objetos você precisa e como eles devem interagir. Nesse caso é necessário um plano de desenvolvimento diferente. Da mesma forma em que descobrimos interfaces de função por encapsulamento e generalização, podemos descobrir interfaces de classe por encapsulamento de dados.</p>

<p>A análise de Markov, de “Análise de Markov”, na página 200, apresenta um bom exemplo. Se baixar o meu código em http://thinkpython2.com/code/markov.py, você vai ver que ele usa duas variáveis globais – suffix_map e prefix – que são lidas e escritas a partir de várias funções.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">suffix_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">prefix</span> <span class="o">=</span> <span class="p">()</span>
</code></pre></div></div>

<p>Como essas variáveis são globais, só podemos executar uma análise de cada vez. Se lermos dois textos, seus prefixos e sufixos seriam acrescentados às mesmas estruturas de dados (o que geraria textos interessantes).</p>

<p>Para executar análises múltiplas e guardá-las separadamente, podemos encapsular o estado de cada análise em um objeto. É assim que fica:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Markov</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">suffix_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="p">()</span>
</code></pre></div></div>

<p>Em seguida, transformamos as funções em métodos. Por exemplo, aqui está process_word:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_word</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">+=</span> <span class="p">(</span><span class="n">word</span><span class="p">,)</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">try</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">suffix_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c"># se não houver entradas deste prefixo, crie uma.</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">suffix_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span><span class="p">]</span>

<span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
</code></pre></div></div>

<p>Transformar um programa como esse – alterando o projeto sem mudar o comportamento – é outro exemplo de refatoração (veja “Refatoração”, na página 70).</p>

<p>Este exemplo sugere um plano de desenvolvimento para projetar objetos e métodos:</p>

<ol>
  <li>
    <p>Comece escrevendo funções que leiam e criem variáveis globais (quando necessário).</p>
  </li>
  <li>
    <p>Uma vez que o programa esteja funcionando, procure associações entre variáveis globais e funções que as usem.</p>
  </li>
  <li>
    <p>Encapsule variáveis relacionadas como atributos de objeto.</p>
  </li>
  <li>
    <p>Transforme as funções associadas em métodos da nova classe.</p>
  </li>
</ol>

<p>Como exercício, baixe o meu código de Markov de http://thinkpython2.com/code/markov.py e siga os passos descritos acima para encapsular as variáveis globais como atributos de uma nova classe chamada Markov.</p>

<p>Solução: http://thinkpython2.com/code/Markov.py (observe o M maiúsculo).</p>

<h2 id="1810---depuração">18.10 - Depuração</h2>

<p>A herança pode dificultar a depuração porque quando você invoca um método em um objeto, pode ser difícil compreender qual método será invocado.</p>

<p>Suponha que esteja escrevendo uma função que funcione com objetos Hand. Você gostaria que ela funcionasse com todos os tipos de Hand, como PokerHands, BridgeHands etc. Se invocar um método como shuffle, poderá receber o que foi definido em Deck, mas se alguma das subclasses ignorar este método, você receberá outra versão. Este comportamento pode ser bom, mas também confuso.</p>

<p>A qualquer momento em que não esteja seguro a respeito do fluxo de execução do seu programa, a solução mais simples é acrescentar instruções de exibição no início dos métodos em questão. Se Deck.shuffle exibir uma mensagem que diz algo como Running Deck.shuffle, então no decorrer da execução do programa ele monitora seu fluxo.</p>

<p>Uma alternativa é usar esta função, que recebe um objeto e um nome de método (como uma string) e retorna a classe que fornece a definição do método:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_defining_class</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">meth_name</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="n">ty</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">meth_name</span> <span class="ow">in</span> <span class="n">ty</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">return</span> <span class="n">ty</span>
</code></pre></div></div>

<p>Aqui está um exemplo:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">hand</span> <span class="o">=</span> <span class="n">Hand</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">find_defining_class</span><span class="p">(</span><span class="n">hand</span><span class="p">,</span> <span class="s">'shuffle'</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">Card</span><span class="o">.</span><span class="n">Deck</span><span class="s">'&gt;</span><span class="err">
</span></code></pre></div></div>

<p>Então o método shuffle deste Hand é o de Deck.</p>

<p><code class="highlighter-rouge">find_defining_class</code> usa o método mro para obter a lista de objetos de classe (tipos) onde os métodos serão procurados. “MRO” significa “ordem de resolução do método”, que é a sequência de classes que o Python pesquisa para “descobrir” um nome de método.</p>

<p>Aqui está uma sugestão de projeto: quando você ignora um método, a interface do novo método deve ser a mesma que a do antigo. Ela deve receber os mesmos parâmetros, retornar o mesmo tipo e obedecer às mesmas precondições e pós-condições. Se seguir esta regra, você descobrirá que qualquer função projetada para funcionar com uma instância de uma classe pai, como Deck, também funcionará com instâncias de classes filho como Hand e PokerHand.</p>

<p>Se violar esta regra, o que se chama de “princípio de substituição de Liskov”, seu código cairá como (desculpe) um castelo de cartas.</p>

<h2 id="1811---glossário">18.11 - Glossário</h2>

<dl>
<dt><a id="glos:codificar" href="18-heranca.html#termo:codificar">codificar</a></dt>
<dd>Representar um conjunto de valores usando outro conjunto de valores construindo um mapeamento entre eles.</dd>

<dt><a id="glos:atributo de classe" href="18-heranca.html#termo:atributo de classe">atributo de classe</a></dt>
<dd>Atributo associado a um objeto de classe. Os atributos de classe são definidos dentro de uma definição de classe, mas fora de qualquer método.</dd>

<dt><a id="glos:atributo de instância" href="18-heranca.html#termo:atributo de instância">atributo de instância</a></dt>
<dd>Atributo associado a uma instância de uma classe.</dd>

<dt><a id="glos:folheado" href="18-heranca.html#termo:folheado">folheado</a></dt>
<dd>Método ou função que apresenta uma interface diferente para outra função sem fazer muitos cálculos.</dd>

<dt><a id="glos:herança" href="18-heranca.html#termo:herança">herança</a></dt>
<dd>Capacidade de definir uma nova classe que seja uma versão modificada de uma classe definida anteriormente.</dd>

<dt><a id="glos:classe-pai" href="18-heranca.html#termo:classe-pai">classe-pai</a></dt>
<dd>Classe da qual uma classe-filho herda.</dd>

<dt><a id="glos:classe-filho" href="18-heranca.html#termo:classe-filho">classe-filho</a></dt>
<dd>Nova classe criada por herança de uma classe existente; também chamada de “subclasse”.</dd>

<dt><a id="glos:relação IS-A" href="18-heranca.html#termo:relação IS-A">relação IS-A</a></dt>
<dd>Relação entre uma classe-filho e sua classe-pai. Também chamada de herança.</dd>

<dt><a id="glos:relação HAS-A" href="18-heranca.html#termo:relação HAS-A">relação HAS-A</a></dt>
<dd>Relação entre duas classes onde as instâncias de uma classe contêm referências a instâncias da outra. Também chamada de composição.</dd>

<dt><a id="glos:dependência" href="18-heranca.html#termo:dependência">dependência</a></dt>
<dd>Relação entre duas classes onde as instâncias de uma classe usam instâncias de outra classe, mas não as guardam como atributos.</dd>

<dt><a id="glos:diagrama de classe" href="18-heranca.html#termo:diagrama de classe">diagrama de classe</a></dt>
<dd>Diagrama que mostra as classes em um programa e as relações entre elas.</dd>

<dt><a id="glos:multiplicidade" href="18-heranca.html#termo:multiplicidade">multiplicidade</a></dt>
<dd>Notação em um diagrama de classe que mostra, para uma relação HAS-A, quantas referências a instâncias da outra classe podem existir.</dd>

<dt><a id="glos:encapsulamento de dados" href="18-heranca.html#termo:encapsulamento de dados">encapsulamento de dados</a></dt>
<dd>Plano de desenvolvimento de programa que envolve um protótipo usando variáveis globais e uma versão final que transforma as variáveis globais em atributos de instância.</dd>

</dl>

<h2 id="1812---exercícios">18.12 - Exercícios</h2>

<h3 id="exercício-181">Exercício 18.1</h3>

<p>Para o seguinte programa, desenhe um diagrama de classe UML que mostre estas classes e as relações entre elas.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PingPongParent</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Ping</span><span class="p">(</span><span class="n">PingPongParent</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pong</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">pong</span> <span class="o">=</span> <span class="n">pong</span>

<span class="k">class</span> <span class="nc">Pong</span><span class="p">(</span><span class="n">PingPongParent</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pings</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">if</span> <span class="n">pings</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">pings</span> <span class="o">=</span> <span class="p">[]</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">else</span><span class="p">:</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">pings</span> <span class="o">=</span> <span class="n">pings</span>
<span class="err"> </span> <span class="err"> </span> <span class="k">def</span> <span class="nf">add_ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ping</span><span class="p">):</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="bp">self</span><span class="o">.</span><span class="n">pings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ping</span><span class="p">)</span>

<span class="n">pong</span> <span class="o">=</span> <span class="n">Pong</span><span class="p">()</span>
<span class="n">ping</span> <span class="o">=</span> <span class="n">Ping</span><span class="p">(</span><span class="n">pong</span><span class="p">)</span>
<span class="n">pong</span><span class="o">.</span><span class="n">add_ping</span><span class="p">(</span><span class="n">ping</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="exercício-182">Exercício 18.2</h3>

<p>Escreva um método Deck chamado <code class="highlighter-rouge">deal_hands</code> que receba dois parâmetros: o número de mãos e o número de cartas por mão. Ele deve criar o número adequado de objetos Hand, lidar com o número adequado de cartas por mão e retornar uma lista de Hands.</p>

<h3 id="exercício-183">Exercício 18.3</h3>

<p>A seguir, as mãos possíveis no pôquer, em ordem crescente de valor e ordem decrescente de probabilidade:</p>

<dl>
<dt>par</dt>
<dd>Duas cartas com o mesmo valor.</dd>

<dt>dois pares</dt>
<dd>Dois pares de cartas com o mesmo valor.</dd>

<dt>trinca</dt>
<dd>Três cartas com o mesmo valor.</dd>

<dt>sequência</dt>
<dd>Cinco cartas com valores em sequência (os ases podem ser altos ou baixos, então Ace-2-3-4-5 é uma sequência, assim como 10-Jack-Queen-King-Ace, mas Queen-King-Ace-2-3 não é.)</dd>

<dt>flush</dt>
<dd>Cinco cartas com o mesmo naipe.</dd>

<dt>full house</dt>
<dd>Três cartas com um valor, duas cartas com outro.</dd>

<dt>quadra</dt>
<dd>Quatro cartas com o mesmo valor.</dd>

<dt>straight flush</dt>
<dd>Cinco cartas em sequência (como definido acima) e com o mesmo naipe.</dd>

</dl>

<p>A meta desses exercícios é estimar a probabilidade de ter estas várias mãos.</p>

<ol>
  <li>Baixe os seguintes arquivos de http://thinkpython2.com/code:</li>
</ol>

<ul>
  <li>
    <p><code class="highlighter-rouge">Card.py</code>: Versão completa das classes Card, Deck e Hand deste capítulo.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">PokerHand.py</code>: Uma implementação incompleta de uma classe que representa uma mão de pôquer e código para testá-la.</p>
  </li>
</ul>

<ol>
  <li>
    <p>Se executar PokerHand.py, você verá que o programa cria mãos de pôquer com 7 cartas e verifica se alguma delas contém um flush. Leia este código com atenção antes de continuar.</p>
  </li>
  <li>
    <p>Acrescente métodos a PokerHand.py chamados <code class="highlighter-rouge">has_pair</code>, <code class="highlighter-rouge">has_twopair</code>, etc. que retornem True ou False conforme a mão cumpra os critérios em questão. Seu código deve funcionar corretamente para “mãos” que contenham qualquer número de cartas (embora 5 e 7 sejam as quantidades mais comuns).</p>
  </li>
  <li>
    <p>Escreva um método chamado classify que descubra a classificação do valor mais alto para uma mão e estabeleça o atributo label em questão. Por exemplo, uma mão de 7 cartas poderia conter um flush e um par; ela deve ser marcada como “flush”.</p>
  </li>
  <li>
    <p>Quando se convencer de que os seus métodos de classificação estão funcionando, o próximo passo deve ser estimar as probabilidades de várias mãos. Escreva uma função em PokerHand.py que embaralhe cartas, divida-as em mãos, classifique as mãos e conte o número de vezes em que várias classificações aparecem.</p>
  </li>
  <li>
    <p>Exiba uma tabela das classificações e suas probabilidades. Execute seu programa com números cada vez maiores de mãos até que os valores de saída convirjam a um grau razoável de exatidão. Compare seus resultados com os valores em http://en.wikipedia.org/wiki/Hand_rankings.</p>
  </li>
</ol>

<p>Solução: http://thinkpython2.com/code/PokerHandSoln.py.</p>


      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/PenseAllen/PensePython2e">PensePython2e</a> is maintained by <a href="https://github.com/PenseAllen">PenseAllen</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
